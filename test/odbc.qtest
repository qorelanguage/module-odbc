#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

%requires QUnit

%try-module odbc
%define NoOdbc
%endtry

%exec-class OdbcTest

class OdbcTest inherits QUnit::Test {
    public {
        TimeZone utcTz = new TimeZone(0);
        *string connStr;

        # Generally compatible types will be here.
        hash Columns = {
            "c": {
                "type": "CHAR(128)",
                "values": ("text", "lorem", "Příliš žluťoučký kůň úpěl ďábelské ódy", "ipsum dolor"),
            },
            "vc": {
                "type": "VARCHAR(128)",
                "values": ("text", "lorem", "Příliš žluťoučký kůň úpěl ďábelské ódy", "ipsum dolor"),
            },
            "sint": {
                "type": "SMALLINT",
                "values": (1, 0, 32767, -32768),
            },
            "i": {
                "type": "INTEGER",
                "values": (2147483647, 0, -1, -2147483648),
            },
            "bint": {
                "type": "BIGINT",
                "values": (2200100100, -9223372036854775807, 0, 9223372036854775807),
            },
            "decim": {
                "type": "DECIMAL(5,2)",
                "values": (123.45n, 0.0n, 999.99n, -999.99n),
            },
            "num": {
                "type": "NUMERIC(5,2)",
                "values": (-123.45n, 0.0n, 999.99n, -999.99n),
            },
            "fltp": {
                "type": "FLOAT(53)",
                "values": (1.72, 3.1456789765432, 0.0, -2.7218281828),
            },
            "r": {
                "type": "REAL",
                "values": (0.00390625, 0.0078125, -0.0078125, 0.0),
            },
            "flt": {
                "type": "FLOAT",
                "values": (0.00390625, 0.0078125, -0.0078125, 0.0),
            },
            "dbl": {
                "type": "DOUBLE PRECISION",
                "values": (1.72, 3.1456789765432, 0.0, -2.7218281828),
            },
            "dt": {
                "type": "DATE",
                "values": odbc_bind(ODBCT_DATE, (2016-01-11, 1970-01-01, 2020-05-20, 1987-01-30)),
                "expected": (2016-01-11, 1970-01-01, 2020-05-20, 1987-01-30),
            },
            "tm": {
                "type": "TIME",
                "values": odbc_bind(ODBCT_TIME, (00:00:00Z, 05:23:17Z, 03:59:20Z, 14:15:16Z)),
                "expected": (0s, 5*60m+23m+17s, 3*60m+59m+20s, 14*60m+15m+16s),
            },
            "tstamp": {
                "type": "TIMESTAMP",
                "values": (2016-01-11T00:00:00, 2016-01-11T05:23:17, 2016-01-11T03:00:20, 2016-01-11T14:15:16),
                "expected": (),
            },
        };
        list ColumnNamesAndTypes;

        # MySQL-specific types.
        hash MysqlColumns = {
            "bin": {
                "type": "BINARY(64)",
                "values": (<bead>, <feed>, <beadaabbccdd>, <1122aabb3344ccdd55667788>),
                "expected": (),
            },
            "vbin": {
                "type": "VARBINARY(64)",
                "values": (<bead>, <feed>, <beadaabbccdd>, <1122aabb3344ccdd55667788>),
            },
            "myblob": {
                "type": "BLOB(64)",
                "values": (<bead>, <feed>, <beadaabbccdd>, <1122aabb3344ccdd55667788>),
            },
            "mybool": {
                "type": "BOOLEAN",
                "values": (True, False, True, True),
                "expected": (1, 0, 1, 1),
            },
            "mytext": {
                "type": "TEXT(128)",
                "values": ("text", "lorem", "Příliš žluťoučký kůň úpěl ďábelské ódy", "ipsum dolor"),
            },
            "tint": {
                "type": "TINYINT",
                "values": (1, 0, 127, -128),
            },
            /*"tintunsig": {
                "type": "TINYINT UNSIGNED",
                "values": (1, 0, 127, 255),
            },*/
            "mint": {
                "type": "MEDIUMINT",
                "values": (1, 0, 8388607, -8388608),
            },
            "mintunsig": {
                "type": "MEDIUMINT UNSIGNED",
                "values": (1, 0, 127, 16777215),
            },
            /*"intunsig": {
                "type": "INTEGER UNSIGNED",
                "values": (1, 0, 127, 4294967295),
            },*/
            /*"mysqlbit": {
                "type": "BIT",
                "values": (0, 1, 1, 0),
            },*/
            "dtime": {
                "type": "DATETIME",
                "values": (2016-01-11T00:00:00, 2016-01-11T05:23:17, 2016-01-11T03:00:20, 2016-01-11T14:15:16),
                "expected": (),
            },
            "yr": {
                "type": "YEAR",
                "values": (2016-01-11, 2012-01-11, 2016-01-30, 1970-01-11),
                "expected": (2016-00-00, 2012-00-00, 2016-00-00, 1970-00-00),
            },
        };

        # PostgreSQL-specific types.
        hash PgsqlColumns = {
            "pgbin": {
                "type": "bytea",
                "values": (<bead>, <feed>, <beadaabbccdd>, <1122aabb3344ccdd55667788>),
            },
            "pgbool": {
                "type": "BOOLEAN",
                "values": (True, False, True, True),
            },
            "pgmoney": {
                "type": "MONEY",
                "values": (123.45n, 0.0n, 92233720368547758.07n, -92233720368547758.08n),
                "expected": (123.45, 0.0, 92233720368547758.07, -92233720368547758.08),
            },
        };
    }

    private {
        *Datasource ds;
        const tableName = "odbc_test_table";
    }

    constructor() : QUnit::Test("OdbcTest", "1.0", \ARGV) {
        addTestCase("Basic test", \basicTest());
        addTestCase("Types test", \typesTest());
        addTestCase("Timezone test", \timezoneTest());
        addTestCase("Array bind test", \arrayBindTest());
        set_return_value(main());
    }

    destructor() {}

    globalSetUp() {
%ifdef NoOdbc
        printf("ODBC module is not available. Exiting.\n");
        exit(0);
%endif

        try {
            initDatasource();
        }
        catch (hash ex) {
            printf("Exception happened during datasource initialization:\n%s: %s\n", ex.err, ex.desc);
            exit(1);
        }
    }

    globalTearDown() {
        if (ds) {
            try {
                ds.exec("DROP TABLE " + tableName);
            }
            catch (hash ex) {
                if (ex.err != "DBI:ODBC:EXEC-ERROR")
                    rethrow;
            }
            ds.commit();
            ds.close();
        }
    }

    initDatasource() {
        connStr = ENV.QORE_DB_CONNSTR_ODBC;
        if (!connStr) {
            printf("No connection string set. Cannot run the tests.\n");
            exit(1);
        }

        ds = new Datasource(connStr);
        if (ds.getDriverName() != "odbc") {
            printf("Cannot execute the odbc tests on a connection using driver %y.\n", ds.getDriverName());
            exit(1);
        }
        ds.open();
        printf("ver: %y\n", ds.getServerVersion());
    }

    basicTest() {
        {
            Datasource test = new Datasource("odbc", "abc", "xyz");
            assertThrows("DBI:ODBC:CONNECTION-ERROR", sub() { test.open(); });
        }

        try {
            ds.exec("DROP TABLE " + tableName);
        }
        catch (hash ex) {
            if (ex.err != "DBI:ODBC:EXEC-ERROR")
                rethrow;
        }
        ds.commit();
        assertEq(0, ds.exec("CREATE TABLE " + tableName + " (id int PRIMARY KEY, text varchar(128))"));
        ds.commit();

        assertEq(1, ds.exec("INSERT INTO " + tableName + " (id, text) VALUES (1, 'abcdef123456')"));
        ds.commit();

        assertEq(1, ds.exec("INSERT INTO " + tableName + " (id, text) VALUES (%v, %v)", 2, "test 789 abc lorem ipsum"));
        ds.commit();

        assertThrows("DBI:ODBC:BIND-ERROR", "not enough parameters passed for binding",
            sub() { ds.exec("INSERT INTO " + tableName + " (id, text) VALUES (%v, %v)", 3); });
        assertThrows("DBI:ODBC:BIND-ERROR", "hash parameter not in correct format for odbc_bind",
            sub() { ds.exec("INSERT INTO " + tableName + " (id, text) VALUES (%v, %v)", 3, {}); });

        assertThrows("DBI:ODBC:EXEC-ERROR", "error during statement execution", sub() { ds.exec("bla bla bla"); });

        hash results1 = {"id": (1, 2), "text": ("abcdef123456", "test 789 abc lorem ipsum")};
        list results2 = ({"id": 1, "text": "abcdef123456"}, {"id": 2, "text": "test 789 abc lorem ipsum"});

        assertEq(results1, ds.exec("SELECT * FROM " + tableName));
        assertEq(results1, ds.select("SELECT * FROM " + tableName));
        assertEq(results2, ds.selectRows("SELECT * FROM " + tableName));
        ds.exec("DROP TABLE " + tableName);
        ds.commit();
    }

    prepareTypesTest() {
        for (int i = 0; i < Columns.tstamp.values.size(); i++) {
            push Columns.tstamp.expected, utcTz.date(Columns.tstamp.values[i]);
        }

        string typesTable = tableName + "_types_test";
        try { ds.exec("DROP TABLE " + typesTable); } catch (e) {}

        bool mysqlDB = False;
        bool pgsqlDB = False;
        bool oracleDB = False;
        bool mssqlDB = False;
        bool sybaseDB = False;

        # Test if connected to a MySQL database.
        try { # LINESTRING is a MySQL-only datatype.
            ds.exec("CREATE TABLE " + typesTable + " (ls LINESTRING)");
            mysqlDB = True;
            try { ds.exec("DROP TABLE " + typesTable); } catch (e) {}
        }
        catch (hash ex) {
            mysqlDB = False;
        }

        # Test if connected to a PostgreSQL database.
        try { # BYTEA is a PostgreSQL-only datatype.
            ds.exec("CREATE TABLE " + typesTable + " (bt bytea)");
            pgsqlDB = True;
            try { ds.exec("DROP TABLE " + typesTable); } catch (e) {}
        }
        catch (hash ex) {
            pgsqlDB = False;
        }

        # Test if connected to an Oracle database.
        try { # BINARY_FLOAT is an Oracle-only datatype.
            ds.exec("CREATE TABLE " + typesTable + " (bf BINARY_FLOAT)");
            oracleDB = True;
            try { ds.exec("DROP TABLE " + typesTable); } catch (e) {}
        }
        catch (hash ex) {
            oracleDB = False;
        }

        # Test if connected to a MSSQL database.
        try { # IMAGE is a MSSQL-only datatype.
            ds.exec("CREATE TABLE " + typesTable + " (img IMAGE)");
            mssqlDB = True;
            try { ds.exec("DROP TABLE " + typesTable); } catch (e) {}
        }
        catch (hash ex) {
            mssqlDB = False;
        }

        # Test if connected to a Sybase database.
        try { # UNIQUEIDENTIFIERSTR is a Sybase-only datatype.
            ds.exec("CREATE TABLE " + typesTable + " (uis UNIQUEIDENTIFIERSTR)");
            sybaseDB = True;
            try { ds.exec("DROP TABLE " + typesTable); } catch (e) {}
        }
        catch (hash ex) {
            sybaseDB = False;
        }

        # Try additional MySQL types.
        if (mysqlDB) {
            string mysqlTable = tableName + "_mysql_types_test";
            try { ds.exec("DROP TABLE " + mysqlTable); } catch (e) {}
            HashIterator mysql(MysqlColumns);
            while (mysql.next()) {
                try {
                    ds.exec("CREATE TABLE " + mysqlTable + " (" + mysql.getKey() + " " + mysql.getValue().type + ")");
                }
                catch (hash ex) { continue; }
                try { ds.exec("DROP TABLE " + mysqlTable); } catch (e) {}

                # Add the type to the typesTest Columns.
                Columns{mysql.getKey()} = mysql.getValue();

                if (mysql.getKey() == "bin") {
                    for (int i = 0; i < Columns.bin.values.size(); i++) {
                        push Columns.bin.expected, Columns.bin.values[i];
                        reference exp = \Columns.bin.expected[i];
                        for (int j = exp.size(); j < 64; j++)
                            exp += <00>;
                    }
                }
                else if (mysql.getKey() == "dtime") {
                    for (int i = 0; i < Columns.dtime.values.size(); i++) {
                        push Columns.dtime.expected, utcTz.date(Columns.dtime.values[i]);
                    }
                }
            }
        }

        # Try additional PostgreSQL types.
        if (pgsqlDB) {
            string pgsqlTable = tableName + "_pgsql_types_test";
            try { ds.exec("DROP TABLE " + pgsqlTable); } catch (e) {}
            HashIterator pgsql(PgsqlColumns);
            while (pgsql.next()) {
                try {
                    ds.exec("CREATE TABLE " + pgsqlTable + " (" + pgsql.getKey() + " " + pgsql.getValue().type + ")");
                }
                catch (hash ex) { continue; }
                try { ds.exec("DROP TABLE " + pgsqlTable); } catch (e) {}

                # Add the type to the typesTest Columns.
                Columns{pgsql.getKey()} = pgsql.getValue();
            }
        }

        # Prepare final list of columns and their types.
        foreach hash col in (Columns.pairIterator()) {
            ColumnNamesAndTypes += col.key + " " + col.value.type;
        }
    }

    typesTest() {
        prepareTypesTest();
        printf("\n**************************\n");
        printf("The following columns and their types are tested in the 'types test':\n");
        foreach string col in (ColumnNamesAndTypes.iterator()) {
            printf("%s\n", col);
        }
        printf("**************************\n\n");

        ds.setOption("numeric-numbers", True);
        try {
            ds.exec("DROP TABLE " + tableName);
        }
        catch (hash ex) {
            if (ex.err != "DBI:ODBC:EXEC-ERROR")
                rethrow;
        }
        ds.commit();

        string def = sprintf(" (%s)", foldl $1 + ", " + $2, ColumnNamesAndTypes);
        assertEq(0, ds.exec("CREATE TABLE " + tableName + def));
        ds.commit();

        list arguments = ();
        foreach hash col in (Columns.pairIterator()) {
            push arguments, col.value.values;
        }

        string valdef = "";
        for (int i = 0; i < ColumnNamesAndTypes.size(); i++)
            valdef += "%v,";
        valdef = valdef.substr(0, valdef.size()-1);

        SQLStatement stmt = new SQLStatement(ds);
        stmt.prepare("INSERT INTO " + tableName + sprintf(" (%s) VALUES (", foldl $1 + ", " + $2, Columns.keys()) + valdef + ")");
        stmt.bindArgs(arguments);
        stmt.exec();
        stmt.commit();

        hash results = Columns;
        foreach string key in (results.keys()) {
            if (exists results{key}.expected)
                results{key} = results{key}.expected;
            else
                results{key} = results{key}.values;
        }

        assertEq(results, ds.exec("SELECT * FROM " + tableName));
        ds.exec("DROP TABLE " + tableName);
        ds.commit();
    }

    timezoneTest() {
        Datasource tzDs = new Datasource(connStr);
        tzDs.setOption("qore-timezone", "Asia/Tokyo");
        tzDs.open();

        try {
            tzDs.exec("DROP TABLE " + tableName);
        }
        catch (hash ex) {
            if (ex.err != "DBI:ODBC:EXEC-ERROR")
                rethrow;
        }
        tzDs.commit();

        assertEq(0, tzDs.exec("CREATE TABLE " + tableName + " (id int, t timestamp)"));
        tzDs.commit();

        assertEq(1, tzDs.exec("INSERT INTO " + tableName + " (id, t) VALUES (%v, %v)", 1, 2016-01-11T00:00:00Z));
        tzDs.commit();
        assertEq(1, tzDs.exec("INSERT INTO " + tableName + " (id, t) VALUES (%v, %v)", 2, 2016-01-11T09:00:00+09:00));
        tzDs.commit();

        hash h = {"id": (1, 2), "t": (2016-01-11T09:00:00+09:00, 2016-01-11T09:00:00+09:00)};
        assertEq(h, tzDs.select("SELECT * FROM " + tableName));

        tzDs.close();
    }

    arrayBindTest() {
        try {
            ds.exec("DROP TABLE " + tableName);
        }
        catch (hash ex) {
            if (ex.err != "DBI:ODBC:EXEC-ERROR")
                rethrow;
        }
        ds.commit();
        assertEq(0, ds.exec("CREATE TABLE " + tableName + " (id int, text varchar(48))"));
        ds.commit();

        SQLStatement stmt = new SQLStatement(ds);
        stmt.prepare("INSERT INTO " + tableName + " (id, text) VALUES (%v, %v)");

        stmt.bindArgs((2, ("text", "abc", "lorem")));
        stmt.exec();
        stmt.commit();

        stmt.bindArgs(((4, 5), ("ipsum", "dolor")));
        stmt.exec();
        stmt.commit();

        stmt.execArgs( ((6,), "sit") );
        stmt.commit();

        hash h = {"id": (2, 2, 2, 4, 5, 6), "text": ("text", "abc", "lorem", "ipsum", "dolor", "sit")};
        assertEq(h, ds.select("SELECT * FROM " + tableName));
    }
}
